<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIFA Confederations Sankey Diagram - p5.js Draggable</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 5px;
            background: #f5f5f5;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 1px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            display: none;
        }
    </style>
</head>



<body>
    <div class="container">
        <h1>FIFA Confederations: 2010, 2014, 2018 vs 2022 World Cup Tournament Stages (Draggable)</h1>
        <div id="p5-container"></div>
        <div id="tooltip"></div>
        <div id="debug-info" class="debug-info"></div>
    </div>

    <script>
        // ==========================================
        // DATA CONFIGURATION
        // ==========================================
        
        const DATA_CONFIG = {
            confederations: {
                AFC: 14,
                OFC: 0,
                CAF: 54,
                CONCACAF: 41,
                CONMEBOL: 10,
                UEFA: 55
            },
            
            tournament2010: [
                {stage: "Fase de Grupos", AFC: 6, OFC: 0, CAF: 5, CONCACAF: 3, CONMEBOL: 5, UEFA: 14},
                {stage: "Octavos de final", AFC: 1, OFC: 0, CAF: 0, CONCACAF: 1, CONMEBOL: 4, UEFA: 10},
                {stage: "Cuartos de final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 2, UEFA: 6},
                {stage: "Semifinal", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 4},
                {stage: "Final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 2}
            ],
            
            tournament2014: [
                {stage: "Fase de Grupos", AFC: 6, OFC: 0, CAF: 5, CONCACAF: 3, CONMEBOL: 5, UEFA: 14},
                {stage: "Octavos de final", AFC: 1, OFC: 0, CAF: 0, CONCACAF: 1, CONMEBOL: 4, UEFA: 10},
                {stage: "Cuartos de final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 2, UEFA: 6},
                {stage: "Semifinal", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 4},
                {stage: "Final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 2}
            ],
            
            tournament2018: [
                {stage: "Fase de Grupos", AFC: 6, OFC: 0, CAF: 5, CONCACAF: 3, CONMEBOL: 5, UEFA: 14},
                {stage: "Octavos de final", AFC: 1, OFC: 0, CAF: 0, CONCACAF: 1, CONMEBOL: 4, UEFA: 10},
                {stage: "Cuartos de final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 2, UEFA: 6},
                {stage: "Semifinal", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 4},
                {stage: "Final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 0, UEFA: 2}
            ],
            
            tournament2022: [
                {stage: "Fase de Grupos", AFC: 6, OFC: 0, CAF: 5, CONCACAF: 4, CONMEBOL: 4, UEFA: 13},
                {stage: "Octavos de final", AFC: 3, OFC: 0, CAF: 2, CONCACAF: 1, CONMEBOL: 2, UEFA: 8},
                {stage: "Cuartos de final", AFC: 0, OFC: 0, CAF: 1, CONCACAF: 0, CONMEBOL: 2, UEFA: 5},
                {stage: "Semifinal", AFC: 0, OFC: 0, CAF: 1, CONCACAF: 0, CONMEBOL: 1, UEFA: 2},
                {stage: "Final", AFC: 0, OFC: 0, CAF: 0, CONCACAF: 0, CONMEBOL: 1, UEFA: 1}
            ]
        };

        // ==========================================
        // VISUAL CONFIGURATION
        // ==========================================
        
        const VISUAL_CONFIG = {
            canvas: {
                width: 2200,  // Increased width for 4 columns
                height: 800
            },
            
            margin: {
                top: 40, 
                right: 60, 
                bottom: 40, 
                left: 60
            },
            
            nodes: {
                width: 20,
                minHeight: 20,
                padding: 15
            },
            
            links: {
                minStrokeWidth: 1,
                maxStrokeWidth: 50,
                opacity: {
                    normal: 150,
                    selected: 255,
                    dimmed: 100
                }
            },
            
            colors: {
                AFC: [255, 207, 107],
                OFC: [78, 205, 196],
                CAF: [69, 183, 209],
                CONCACAF: [150, 206, 180],
                CONMEBOL: [105, 214, 167],
                UEFA: [221, 90, 100]
            }
        };

        // ==========================================
        // GLOBAL STATE VARIABLES
        // ==========================================
        
        let canvas;
        let tooltip;
        let debugInfo;
        let selectedElement = null;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let debugMode = false;
        
        // Data structures
        let confederationNodes = [];
        let stage2010Nodes = [];
        let stage2014Nodes = [];
        let stage2018Nodes = [];
        let stage2022Nodes = [];
        let allNodes = [];
        let links = [];

        // ==========================================
        // INITIALIZATION FUNCTIONS
        // ==========================================
        
        function setup() {
            // Initialize canvas and DOM elements
            canvas = createCanvas(VISUAL_CONFIG.canvas.width, VISUAL_CONFIG.canvas.height);
            canvas.parent('p5-container');
            tooltip = select('#tooltip');
            debugInfo = select('#debug-info');
            
            // Initialize data structures
            initializeNodes();
            createLinks();
            updateAllNodesArray();
            
            // Set text properties
            textAlign(CENTER, CENTER);
            textSize(11);
            
            console.log('Sankey diagram initialized successfully');
            console.log(`Nodes: ${allNodes.length}, Links: ${links.length}`);
        }

        function initializeNodes() {
            console.log('Initializing nodes...');
            
            // Clear existing nodes
            confederationNodes = [];
            stage2010Nodes = [];
            stage2014Nodes = [];
            stage2018Nodes = [];
            stage2022Nodes = [];
            
            // Create confederation nodes
            createConfederationNodes();
            
            // Create tournament stage nodes for all years
            createTournamentNodes(DATA_CONFIG.tournament2010, stage2010Nodes, 2010);
            createTournamentNodes(DATA_CONFIG.tournament2014, stage2014Nodes, 2014);
            createTournamentNodes(DATA_CONFIG.tournament2018, stage2018Nodes, 2018);
            createTournamentNodes(DATA_CONFIG.tournament2022, stage2022Nodes, 2022);
            
            console.log(`Created ${confederationNodes.length} confederation nodes`);
            console.log(`Created ${stage2010Nodes.length} 2010 stage nodes`);
            console.log(`Created ${stage2014Nodes.length} 2014 stage nodes`);
            console.log(`Created ${stage2018Nodes.length} 2018 stage nodes`);
            console.log(`Created ${stage2022Nodes.length} 2022 stage nodes`);
        }

        function createConfederationNodes() {
            const confederations = Object.keys(DATA_CONFIG.confederations);
            const plotHeight = VISUAL_CONFIG.canvas.height - VISUAL_CONFIG.margin.top - VISUAL_CONFIG.margin.bottom;
            const totalMembers = Object.values(DATA_CONFIG.confederations).reduce((sum, val) => sum + val, 0);
            
            let yPos = VISUAL_CONFIG.margin.top;
            
            confederations.forEach((conf, i) => {
                const members = DATA_CONFIG.confederations[conf];
                const height = Math.max(VISUAL_CONFIG.nodes.minHeight, (members / totalMembers) * plotHeight);
                
                const node = {
                    id: `conf_${conf}`,
                    name: conf,
                    displayName: `${conf} (${members} members)`,
                    x: VISUAL_CONFIG.margin.left,
                    y: yPos,
                    width: VISUAL_CONFIG.nodes.width,
                    height: height,
                    members: members,
                    type: 'confederation',
                    draggable: true,
                    segments: null
                };
                
                confederationNodes.push(node);
                yPos += height;
            });
        }

        function createTournamentNodes(tournamentData, nodeArray, year) {
            const plotWidth = VISUAL_CONFIG.canvas.width - VISUAL_CONFIG.margin.left - VISUAL_CONFIG.margin.right;
            
            // Calculate x position for 4 columns (2010, 2014, 2018, 2022)
            let xPosition;
            switch(year) {
                case 2010:
                    xPosition = VISUAL_CONFIG.margin.left + plotWidth * 0.25;
                    break;
                case 2014:
                    xPosition = VISUAL_CONFIG.margin.left + plotWidth * 0.45;
                    break;
                case 2018:
                    xPosition = VISUAL_CONFIG.margin.left + plotWidth * 0.65;
                    break;
                case 2022:
                    xPosition = VISUAL_CONFIG.margin.left + plotWidth * 0.85;
                    break;
                default:
                    xPosition = VISUAL_CONFIG.margin.left + plotWidth * 0.5;
            }
            
            let yPos = VISUAL_CONFIG.margin.top;
            
            tournamentData.forEach((stageData, i) => {
                const totalTeams = Object.keys(stageData)
                    .filter(key => key !== 'stage')
                    .reduce((sum, conf) => sum + (stageData[conf] || 0), 0);
                
                if (totalTeams > 0) {
                    const height = Math.max(VISUAL_CONFIG.nodes.minHeight, totalTeams * 8);
                    
                    const node = {
                        id: `stage_${year}_${i}`,
                        name: stageData.stage,
                        displayName: `${year} ${stageData.stage}`,
                        x: xPosition,
                        y: yPos,
                        width: VISUAL_CONFIG.nodes.width,
                        height: height,
                        totalTeams: totalTeams,
                        stageData: stageData,
                        type: `stage${year}`,
                        year: year,
                        draggable: true,
                        segments: []
                    };
                    
                    nodeArray.push(node);
                    yPos += height + VISUAL_CONFIG.nodes.padding;
                }
            });
        }

        function createLinks() {
            console.log('Creating links...');
            links = [];
            
            const confederations = Object.keys(DATA_CONFIG.confederations);
            
            // Create links from confederations to all tournament years
            createLinksToStages(confederations, confederationNodes, stage2010Nodes, 2010);
            createLinksToStages(confederations, confederationNodes, stage2014Nodes, 2014);
            createLinksToStages(confederations, confederationNodes, stage2018Nodes, 2018);
            createLinksToStages(confederations, confederationNodes, stage2022Nodes, 2022);
            
            console.log(`Created ${links.length} links`);
        }

        function createLinksToStages(confederations, sourceNodes, targetNodes, year) {
            confederations.forEach(conf => {
                const confNode = sourceNodes.find(n => n.name === conf);
                if (!confNode) return;
                
                targetNodes.forEach(stageNode => {
                    const teams = stageNode.stageData[conf] || 0;
                    if (teams > 0) {
                        const link = {
                            id: `link_${conf}_${year}_${stageNode.name}`,
                            source: confNode,
                            target: stageNode,
                            value: teams,
                            confederation: conf,
                            year: year,
                            stage: stageNode.name,
                            bounds: null
                        };
                        
                        links.push(link);
                    }
                });
            });
        }

        function updateAllNodesArray() {
            allNodes = [...confederationNodes, ...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes];
        }

        // ==========================================
        // DRAWING FUNCTIONS
        // ==========================================
        
        function draw() {
            background(245);
            
            // Update node segments before drawing
            updateNodeSegments();
            
            // Draw all components
            drawLinks();
            drawNodes();
            drawLabels();
            
            // Draw debug information if enabled
            if (debugMode) {
                drawDebugInfo();
            }
        }

        function updateNodeSegments() {
            // Update segments for all tournament stage nodes
            [...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes].forEach(node => {
                node.segments = [];
                const confederations = Object.keys(DATA_CONFIG.confederations);
                let currentY = node.y;
                
                confederations.forEach(conf => {
                    const teams = node.stageData[conf] || 0;
                    if (teams > 0) {
                        const segmentHeight = (teams / node.totalTeams) * node.height;
                        
                        node.segments.push({
                            confederation: conf,
                            teams: teams,
                            bounds: {
                                x: node.x,
                                y: currentY,
                                width: node.width,
                                height: segmentHeight
                            }
                        });
                        
                        currentY += segmentHeight;
                    }
                });
            });
        }

        function drawLinks() {
            // Calculate maximum value for proportional scaling
            const maxValue = Math.max(...links.map(link => link.value));
            
            // Set stroke cap to square for flat endings
            strokeCap(SQUARE);
            
            links.forEach(link => {
                drawSingleLink(link, maxValue);
            });
            
            // Reset stroke cap
            strokeCap(ROUND);
        }

        function drawSingleLink(link, maxValue) {
            // Calculate opacity based on selection state
            let opacity = VISUAL_CONFIG.links.opacity.normal;
            
            if (selectedElement === link) {
                opacity = VISUAL_CONFIG.links.opacity.selected;
            } else if (selectedElement && selectedElement.type === 'confederation' && 
                      selectedElement.name === link.confederation) {
                opacity = VISUAL_CONFIG.links.opacity.selected;
            } else if (selectedElement && selectedElement !== link) {
                opacity = VISUAL_CONFIG.links.opacity.dimmed;
            }
            
            // Set stroke properties
            const [r, g, b] = VISUAL_CONFIG.colors[link.confederation];
            const strokeWidth = VISUAL_CONFIG.links.minStrokeWidth + 
                (link.value / maxValue) * (VISUAL_CONFIG.links.maxStrokeWidth - VISUAL_CONFIG.links.minStrokeWidth);
            
            stroke(r, g, b, opacity);
            strokeWeight(strokeWidth);
            
            // Calculate link positions
            const positions = calculateLinkPositions(link);
            const { sourceX, sourceY, targetX, targetY, midX } = positions;
            
            // Draw bezier curve
            noFill();
            bezier(sourceX, sourceY, midX, sourceY, midX, targetY, targetX, targetY);
            
            // Store bounds for interaction
            link.bounds = {
                x1: sourceX,
                y1: sourceY,
                x2: targetX,
                y2: targetY,
                midX: midX,
                strokeWidth: strokeWidth
            };
        }

        function calculateLinkPositions(link) {
            const sourceX = link.source.x + link.source.width;
            const targetX = link.target.x;
            const midX = (sourceX + targetX) / 2;
            
            let sourceY, targetY;
            
            // Calculate source Y position
            if (link.source.type === 'confederation') {
                sourceY = calculateConfederationLinkY(link);
            } else {
                sourceY = link.source.y + link.source.height / 2;
            }
            
            // Calculate target Y position
            targetY = calculateTargetLinkY(link);
            
            return { sourceX, sourceY, targetX, targetY, midX };
        }

        function calculateConfederationLinkY(link) {
            // Calculate proportional position based on confederation's links
            const confLinks = links.filter(l => 
                l.source === link.source && 
                l.year === link.year
            ).sort((a, b) => {
                const allStageNodes = [...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes];
                return allStageNodes.findIndex(n => n === a.target) - 
                       allStageNodes.findIndex(n => n === b.target);
            });
            
            let cumulativeHeight = 0;
            const linkIndex = confLinks.indexOf(link);
            
            for (let i = 0; i < linkIndex; i++) {
                cumulativeHeight += confLinks[i].value;
            }
            
            const totalHeight = confLinks.reduce((sum, l) => sum + l.value, 0);
            const proportionalY = (cumulativeHeight + link.value / 2) / totalHeight;
            
            return link.source.y + proportionalY * link.source.height;
        }

        function calculateTargetLinkY(link) {
            // Find the specific confederation segment in the target node
            if (link.target.segments) {
                const segment = link.target.segments.find(s => s.confederation === link.confederation);
                if (segment) {
                    return segment.bounds.y + segment.bounds.height / 2;
                }
            }
            
            return link.target.y + link.target.height / 2;
        }

        function drawNodes() {
            // Draw confederation nodes
            confederationNodes.forEach(node => {
                drawConfederationNode(node);
            });
            
            // Draw tournament stage nodes with segments
            [...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes].forEach(node => {
                drawStageNode(node);
            });
        }

        function drawConfederationNode(node) {
            // Calculate opacity
            let opacity = VISUAL_CONFIG.links.opacity.normal;
            
            if (selectedElement === node) {
                opacity = VISUAL_CONFIG.links.opacity.selected;
            } else if (selectedElement && selectedElement !== node) {
                opacity = VISUAL_CONFIG.links.opacity.dimmed;
            }
            
            // Draw node rectangle
            const [r, g, b] = VISUAL_CONFIG.colors[node.name];
            fill(r, g, b, opacity);
            stroke(255);
            strokeWeight(1);
            
            rect(node.x, node.y, node.width, node.height);
            
            // Update bounds for interaction
            node.bounds = {
                x: node.x,
                y: node.y,
                width: node.width,
                height: node.height
            };
        }

        function drawStageNode(node) {
            const confederations = Object.keys(DATA_CONFIG.confederations);
            
            node.segments.forEach(segment => {
                // Calculate opacity
                let opacity = VISUAL_CONFIG.links.opacity.normal;
                
                if (selectedElement && selectedElement.type === 'confederation' && 
                    selectedElement.name === segment.confederation) {
                    opacity = VISUAL_CONFIG.links.opacity.selected;
                } else if (selectedElement && selectedElement.type === 'segment' && 
                          selectedElement.segment.confederation === segment.confederation) {
                    opacity = VISUAL_CONFIG.links.opacity.selected;
                } else if (selectedElement) {
                    opacity = VISUAL_CONFIG.links.opacity.dimmed;
                }
                
                // Draw segment
                const [r, g, b] = VISUAL_CONFIG.colors[segment.confederation];
                fill(r, g, b, opacity);
                stroke(255);
                strokeWeight(0.5);
                
                const bounds = segment.bounds;
                rect(bounds.x, bounds.y, bounds.width, bounds.height);
            });
            
            // Update overall node bounds
            node.bounds = {
                x: node.x,
                y: node.y,
                width: node.width,
                height: node.height
            };
        }

        function drawLabels() {
            fill(50);
            noStroke();
            
            // Draw confederation labels
            textAlign(LEFT, CENTER);
            textSize(11);
            confederationNodes.forEach(node => {
                text(node.displayName, node.x + node.width + 10, node.y + node.height / 2);
            });
            
            // Draw stage labels for all years
            textAlign(CENTER, CENTER);
            [...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes].forEach(node => {
                text(node.displayName, node.x + node.width / 2, node.y - 15);
            });
        }

        function drawDebugInfo() {
            // Draw node boundaries and IDs
            stroke(255, 0, 0, 100);
            strokeWeight(1);
            noFill();
            
            allNodes.forEach(node => {
                rect(node.bounds.x, node.bounds.y, node.bounds.width, node.bounds.height);
                
                fill(255, 0, 0);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(8);
                text(node.id, node.bounds.x + node.bounds.width/2, node.bounds.y - 5);
            });
            
            // Update debug info panel
            const debugText = `
                Nodes: ${allNodes.length}
                Links: ${links.length}
                Selected: ${selectedElement ? selectedElement.id || selectedElement.type : 'None'}
                Dragged: ${draggedNode ? draggedNode.id : 'None'}
                Mouse: (${mouseX}, ${mouseY})
            `;
            debugInfo.html(debugText.trim());
        }

        // ==========================================
        // INTERACTION FUNCTIONS
        // ==========================================
        
        function mouseMoved() {
            if (draggedNode) return; // Don't show tooltips while dragging
            
            const hoveredElement = getHoveredElement();
            if (hoveredElement) {
                showTooltip(hoveredElement);
            } else {
                hideTooltip();
            }
        }

        function mousePressed() {
            const clickedElement = getHoveredElement();
            
            if (clickedElement) {
                handleElementClick(clickedElement);
            } else {
                selectedElement = null;
            }
            
            // Start dragging if clicking on a draggable node
            const clickedNode = getClickedNode();
            if (clickedNode && clickedNode.draggable) {
                startDragging(clickedNode);
            }
        }

        function mouseDragged() {
            if (draggedNode) {
                updateNodePosition(draggedNode, mouseX - dragOffset.x, mouseY - dragOffset.y);
                hideTooltip(); // Hide tooltip while dragging
            }
        }

        function mouseReleased() {
            if (draggedNode) {
                console.log(`Stopped dragging ${draggedNode.id}`);
                draggedNode = null;
            }
        }

        function keyPressed() {
            // Toggle debug mode with 'D' key
            if (key === 'd' || key === 'D') {
                debugMode = !debugMode;
                if (debugMode) {
                    debugInfo.style('display', 'block');
                    console.log('Debug mode enabled');
                } else {
                    debugInfo.style('display', 'none');
                    console.log('Debug mode disabled');
                }
            }
        }

        // ==========================================
        // HELPER FUNCTIONS
        // ==========================================
        
        function getHoveredElement() {
            // Check confederation nodes
            for (let node of confederationNodes) {
                if (isPointInRect(mouseX, mouseY, node.bounds)) {
                    return node;
                }
            }
            
            // Check stage nodes and segments for all years
            for (let node of [...stage2010Nodes, ...stage2014Nodes, ...stage2018Nodes, ...stage2022Nodes]) {
                if (node.segments) {
                    for (let segment of node.segments) {
                        if (isPointInRect(mouseX, mouseY, segment.bounds)) {
                            return {
                                type: 'segment',
                                node: node,
                                segment: segment
                            };
                        }
                    }
                }
            }
            
            // Check links
            for (let link of links) {
                if (link.bounds && isPointNearBezier(mouseX, mouseY, link.bounds)) {
                    return link;
                }
            }
            
            return null;
        }

        function getClickedNode() {
            for (let node of allNodes) {
                if (node.bounds && isPointInRect(mouseX, mouseY, node.bounds)) {
                    return node;
                }
            }
            return null;
        }

        function isPointInRect(px, py, bounds) {
            return px >= bounds.x && px <= bounds.x + bounds.width &&
                   py >= bounds.y && py <= bounds.y + bounds.height;
        }

        function isPointNearBezier(px, py, bounds) {
            if (!bounds) return false;
            
            const distToStart = dist(px, py, bounds.x1, bounds.y1);
            const distToEnd = dist(px, py, bounds.x2, bounds.y2);
            const distToMid = dist(px, py, bounds.midX, (bounds.y1 + bounds.y2) / 2);
            
            const interactionRadius = Math.max(10, bounds.strokeWidth / 2 + 5);
            
            return distToStart < interactionRadius || distToEnd < interactionRadius || distToMid < interactionRadius;
        }

        function handleElementClick(element) {
            selectedElement = (selectedElement === element) ? null : element;
            console.log('Selected:', selectedElement ? (selectedElement.id || selectedElement.type) : 'None');
        }

        function startDragging(node) {
            draggedNode = node;
            dragOffset.x = mouseX - node.x;
            dragOffset.y = mouseY - node.y;
            console.log(`Started dragging ${node.id}`);
        }

        function updateNodePosition(node, newX, newY) {
            // Constrain node position to canvas bounds
            const constrainedX = constrain(newX, 0, VISUAL_CONFIG.canvas.width - node.width);
            const constrainedY = constrain(newY, 0, VISUAL_CONFIG.canvas.height - node.height);
            
            node.x = constrainedX;
            node.y = constrainedY;
        }

        function showTooltip(element) {
            let tooltipText = '';
            
            if (element.type === 'confederation') {
                tooltipText = `${element.name}<br/>Total Members: ${element.members}`;
            } else if (element.type === 'segment') {
                tooltipText = `${element.segment.confederation} in ${element.node.displayName}<br/>Teams: ${element.segment.teams}`;
            } else if (element.type === 'stage2018' || element.type === 'stage2022') {
                tooltipText = `${element.displayName}<br/>Total Teams: ${element.totalTeams}`;
            } else if (element.confederation) {
                // Link
                tooltipText = `${element.confederation} â†’ ${element.year} ${element.stage}<br/>Teams: ${element.value}`;
            }
            
            tooltip.html(tooltipText);
            tooltip.style('display', 'block');
            tooltip.style('left', (mouseX + canvas.canvas.offsetLeft + 10) + 'px');
            tooltip.style('top', (mouseY + canvas.canvas.offsetTop - 30) + 'px');
        }

        function hideTooltip() {
            tooltip.style('display', 'none');
        }

        // ==========================================
        // UTILITY FUNCTIONS
        // ==========================================
        
        function logSystemInfo() {
            console.log('=== Sankey Diagram System Info ===');
            console.log(`Canvas: ${VISUAL_CONFIG.canvas.width}x${VISUAL_CONFIG.canvas.height}`);
            console.log(`Confederation nodes: ${confederationNodes.length}`);
            console.log(`2010 stage nodes: ${stage2010Nodes.length}`);
            console.log(`2014 stage nodes: ${stage2014Nodes.length}`);
            console.log(`2018 stage nodes: ${stage2018Nodes.length}`);
            console.log(`2022 stage nodes: ${stage2022Nodes.length}`);
            console.log(`Total links: ${links.length}`);
            console.log(`Debug mode: ${debugMode ? 'Enabled' : 'Disabled'}`);
            console.log('=== End System Info ===');
        }

        // Initialize system info logging
        setTimeout(logSystemInfo, 1000);
    </script>
</body>
</html>